#lang ivy1.7

# This file contains a liveness proof of the ticket protocol, and
# illustrates Ivy's liveness to safety tactic on an infinite-state
# system that requires dynamic abstraction. The example is discussed
# in the following papers:
#
# Oded Padon, Jochen Hoenicke, Giuliano Losa, Andreas Podelski, Mooly
# Sagiv, and Sharon Shoham: Reducing Liveness to Safety in First-Order
# Logic. POPL 2018: Article 26.
#
# Oded Padon, Jochen Hoenicke, Kenneth L. McMillan, Andreas Podelski,
# Mooly Sagiv, Sharon Shoham: Temporal Prophecy for Proving Temporal
# Properties of Infinite-State Systems. FMCAD 2018: 1-11
#
# To verify this file, run:
#
#     $ ivy_check ticket.ivy
#     ...
#     OK
#

################################################################################
# A liveness proof of the ticket protocol
################################################################################


################################################################################
# Module for axiomatizing a total order
################################################################################

module total_order(r) = {
    axiom r(X,X)                        # Reflexivity
    axiom r(X, Y) & r(Y, Z) -> r(X, Z)  # Transitivity
    axiom r(X, Y) & r(Y, X) -> X = Y    # Anti-symmetry
    axiom r(X, Y) | r(Y, X)             # Totality
}

################################################################################
#
# Types, relations and functions describing the state
#
################################################################################


isolate mutex_protocol = {

    type thread

    action step_atomic_cas(t:thread)
    action step_futex_wait(t:thread)
    action step_kernel_wait(t:thread)
    action step_atomic_store(t:thread)
    action step_futex_wake(t:thread)
    action step_finished(t:thread)

    specification {

    # global state (lock and futex queue)
    relation locked
    relation queue(T:thread)

    # local state (program counters)
    relation pc_atomic_cas(T:thread)
    relation pc_futex_wait(T:thread)
    relation pc_kernel_wait(T:thread)
    relation pc_atomic_store(T:thread)
    relation pc_futex_wake(T:thread)
    relation pc_finished(T:thread)

    # for tracking fairness assumptions
	relation scheduled(T:thread)

	after init {
            pc_atomic_cas(T) := true;
            pc_futex_wait(T) := false;
            pc_kernel_wait(T) := false;
            pc_atomic_store(T) := false;
            pc_futex_wake(T) := false;
            pc_finished(T) := false;
            locked := false;
            queue(T) := false;
            scheduled(T) := false;
	}

	before step_atomic_cas {
        require pc_atomic_cas(t);
        pc_atomic_cas(t) := false;
        if locked {
            pc_futex_wait(t) := true;
        } else {
            # successfully acquired the lock
            pc_atomic_store(t) := true;
            locked := true;
        }
        scheduled(T) := T = t;
	    scheduled(T) := false;
	}

    before step_futex_wait {
        require pc_futex_wait(t);
        pc_futex_wait(t) := false;
        if locked {
            # start waiting in kernel
            pc_kernel_wait(t) := true;
            queue(t) := true;
        } else {
            pc_atomic_cas(t) := true;
        }
        scheduled(T) := T = t;
        scheduled(T) := false;
    }

    before step_kernel_wait {
        require pc_kernel_wait(t);
        if ~queue(t) {
            pc_kernel_wait(t) := false;
            pc_atomic_cas(t) := true;
        }
        scheduled(T) := T = t;
        scheduled(T) := false;
    }

    before step_atomic_store {
        require pc_atomic_store(t);
        pc_atomic_store(t) := false;
        pc_futex_wake(t) := true;
        locked := false;
        scheduled(T) := T = t;
        scheduled(T) := false;
    }

    before step_futex_wake {
        require pc_futex_wake(t);
        pc_futex_wake(t) := false;
        if some t0:thread. queue(t0) {
            queue(t0) := false;
        } # otherwise no signalling is needed
        pc_finished(t) := true;
        scheduled(T) := T = t;
        scheduled(T) := false;
    }

	################################################################################
	#
	# Invariants for proving safety (also help for liveness)
	#
	################################################################################

	# basic

    invariant pc_atomic_cas(T) | pc_futex_wait(T) | pc_kernel_wait(T) | pc_atomic_store(T) | pc_futex_wake(T) | pc_finished(T)
    invariant ~pc_atomic_cas(T) | ~pc_futex_wait(T)
    invariant ~pc_atomic_cas(T) | ~pc_kernel_wait(T)
    invariant ~pc_atomic_cas(T) | ~pc_atomic_store(T)
    invariant ~pc_atomic_cas(T) | ~pc_futex_wake(T)
    invariant ~pc_atomic_cas(T) | ~pc_finished(T)
    invariant ~pc_futex_wait(T) | ~pc_kernel_wait(T)
    invariant ~pc_futex_wait(T) | ~pc_atomic_store(T)
    invariant ~pc_futex_wait(T) | ~pc_futex_wake(T)
    invariant ~pc_futex_wait(T) | ~pc_finished(T)
    invariant ~pc_kernel_wait(T) | ~pc_atomic_store(T)
    invariant ~pc_kernel_wait(T) | ~pc_futex_wake(T)
    invariant ~pc_kernel_wait(T) | ~pc_finished(T)
    invariant ~pc_atomic_store(T) | ~pc_futex_wake(T)
    invariant ~pc_atomic_store(T) | ~pc_finished(T)
    invariant ~pc_futex_wake(T) | ~pc_finished(T)

	# safety property
	invariant pc_atomic_store(T1) & pc_atomic_store(T2) -> T1 = T2

	# inductive invariant for proving safety
    invariant pc_atomic_store(T) -> locked
    invariant locked -> exists T. pc_atomic_store(T)

        ################################################################################
	#
	# Temporal property and its proof
	#
	################################################################################



    individual t0:thread  # witness for the formula (exists T0. (globally ~(pc_finished(T0))))

	temporal property [nonstarvation] (
            # temporal witnesses
            (exists T0. (globally ~pc_finished(T0))) -> (globally ~(pc_finished(t0)))
        ) -> (
            # temporal property
            (forall T. globally (eventually scheduled(T))) -> (forall T. eventually (pc_finished(T)))
        )
    proof {
            tactic l2s with

	        invariant ~scheduled(T)  # scheduled is only true transiently inside actions

            # basic, should be added automatically
            invariant l2s_waiting | l2s_frozen | l2s_saved
            invariant ~l2s_waiting | ~l2s_frozen
            invariant ~l2s_waiting | ~l2s_saved
            invariant ~l2s_frozen  | ~l2s_saved

            # safety invariants for saved copy
            invariant l2s_saved -> (
            ($l2s_s T. pc_atomic_cas(T))(T) | ($l2s_s T. pc_futex_wait(T))(T) | ($l2s_s T. pc_kernel_wait(T))(T) | ($l2s_s T. pc_atomic_store(T))(T) | ($l2s_s T. pc_futex_wake(T))(T) | ($l2s_s T. pc_finished(T))(T)
            )

            invariant l2s_saved -> (~($l2s_s T. pc_atomic_cas(T))(T) | ~($l2s_s T. pc_futex_wait(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_atomic_cas(T))(T) | ~($l2s_s T. pc_kernel_wait(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_atomic_cas(T))(T) | ~($l2s_s T. pc_atomic_store(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_atomic_cas(T))(T) | ~($l2s_s T. pc_futex_wake(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_atomic_cas(T))(T) | ~($l2s_s T. pc_finished(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_futex_wait(T))(T) | ~($l2s_s T. pc_kernel_wait(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_futex_wait(T))(T) | ~($l2s_s T. pc_atomic_store(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_futex_wait(T))(T) | ~($l2s_s T. pc_futex_wake(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_futex_wait(T))(T) | ~($l2s_s T. pc_finished(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_kernel_wait(T))(T) | ~($l2s_s T. pc_atomic_store(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_kernel_wait(T))(T) | ~($l2s_s T. pc_futex_wake(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_kernel_wait(T))(T) | ~($l2s_s T. pc_finished(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_atomic_store(T))(T) | ~($l2s_s T. pc_futex_wake(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_atomic_store(T))(T) | ~($l2s_s T. pc_finished(T))(T))
            invariant l2s_saved -> (~($l2s_s T. pc_futex_wake(T))(T) | ~($l2s_s T. pc_finished(T))(T))

            # safety property
            invariant l2s_saved -> (($l2s_s T. pc_atomic_store(T))(T1) & ($l2s_s T. pc_atomic_store(T))(T2) -> T1 = T2)

            # inductive invariant for proving safety
            invariant l2s_saved -> (($l2s_s T. pc_atomic_store(T))(T) -> ($l2s_s. locked))
            invariant l2s_saved -> (($l2s_s. locked) -> exists T. ($l2s_s T. pc_atomic_store(T))(T))


            # basic temporal information from temporal property
            invariant globally eventually scheduled(T)
            invariant globally (~pc_finished(t0))
            invariant ~pc_finished(t0)

            # ignore dynamic abstraction business
            invariant forall T:thread. l2s_d(T)
            invariant (l2s_frozen | l2s_saved) -> forall T:thread. l2s_a(T)

    }
	# proof {
    #         tactic l2s with

    #         ################################################################################
    #         #
    #         # Invariants for proving liveness by l2s
	#     #
	#     ################################################################################

    #         # basic
	#     invariant ~scheduled(T)  # scheduled is only true transiently inside actions
    #         invariant globally eventually scheduled(T)
    #         invariant eventually (pc2(t0) & globally ~pc3(t0))
    #         invariant ~($l2s_w. (pc2(t0) & globally ~pc3(t0))) <-> (pc2(t0) & globally ~pc3(t0))

    #         # basic, should be added automatically
    #         invariant l2s_waiting | l2s_frozen | l2s_saved
    #         invariant ~l2s_waiting | ~l2s_frozen
    #         invariant ~l2s_waiting | ~l2s_saved
    #         invariant ~l2s_frozen  | ~l2s_saved

	#     # still basic
    #         invariant l2s_frozen -> (pc2(t0) & globally ~pc3(t0))
    #         invariant l2s_saved  -> (pc2(t0) & globally ~pc3(t0))
    #         invariant l2s_saved  -> (($l2s_s T,K. m(T,K))(t0,K) <-> m(t0,K))
    #         invariant l2s_saved  -> le( ($ l2s_s . service) , service)
    #         invariant l2s_saved  -> le( ($ l2s_s . next_ticket) , next_ticket)

	#     # more properties of reachable protocol states useful for liveness proof
    #         invariant pc1(T) & m(T,M) & M ~= zero -> ~le(service, M)
    #         invariant forall K:ticket. ~le(next_ticket, K) & le(service, K) -> exists T:thread. m(T,K) & ~pc1(T)
    #         invariant exists M. m(t0, M)

    #         # invariant that l2s_d is large enough
    #         invariant l2s_d(t0)
    #         invariant ~pc1(T) -> l2s_d(T)
    #         invariant le(K,next_ticket) -> l2s_d(K)
    #         # invariant that l2s_a is large enough
    #         invariant ~l2s_waiting -> l2s_a(t0)
    #         invariant ~l2s_waiting & m(T,K) & m(t0,K0) & ~le(K0,K) & ~pc1(T) -> l2s_a(T)
    #         invariant ~l2s_waiting & m(t0,K0) & le(K,K0) -> l2s_a(K)

    #         # thread that have not been scheduled have not changed
    #         invariant l2s_saved & ($l2s_w T. scheduled(T))(T) -> (($l2s_s T. pc1(T))(T) <-> pc1(T))
    #         invariant l2s_saved & ($l2s_w T. scheduled(T))(T) -> (($l2s_s T. pc2(T))(T) <-> pc2(T))
    #         invariant l2s_saved & ($l2s_w T. scheduled(T))(T) -> (($l2s_s T. pc3(T))(T) <-> pc3(T))
    #         invariant l2s_saved & ($l2s_w T. scheduled(T))(T) -> (($l2s_s T,K. m(T,K))(T,K) <-> m(T,K))

    #         # the thread that must advance - the thread that had the service as its local ticket at the save point
    #         invariant (
    #             l2s_saved &
    #             ($l2s_s T,K. m(T,K))(T,($l2s_s. service)) &
    #             ~($l2s_w X. scheduled(X))(T) &
    #             ($l2s_s T. pc2(T))(T) &
    #             m(T,K) &
    #             m(t0,K0)
    #         ) -> (
    #             (pc1(T) & K = ($l2s_s. service)) |
    #             (pc2(T) & ~le(K,K0)) |
    #             (pc3(T) & K = ($l2s_s. service))
    #         )
    #         invariant (
    #             l2s_saved &
    #             ($l2s_s T,K. m(T,K))(T,($l2s_s. service)) &
    #             ~($l2s_w T. scheduled(T))(T) &
    #             ($l2s_s T. pc3(T))(T) &
    #             m(T,K) &
    #             m(t0,K0)
    #         ) -> (
    #             (pc1(T) & K = ($l2s_s. service) & ~le(service, ($l2s_s. service))) |
    #             (pc2(T) & ~le(K,K0))
    #         )
	# }
}
}

export mutex_protocol.step_atomic_cas
export mutex_protocol.step_futex_wait
export mutex_protocol.step_kernel_wait
export mutex_protocol.step_atomic_store
export mutex_protocol.step_futex_wake
export mutex_protocol.step_finished
